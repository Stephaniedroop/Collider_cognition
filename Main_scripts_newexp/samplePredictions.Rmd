---
title: "sample_predictions"
output: html_document
date: "2025-09-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lmerTest)
```

## Generate samples from the model

The model predictions are currently probability distributions spread over the 8 node values (the 8 explanations for each possible outcome). We want to force the model to give an actual answer, to pair with each participant's observation. This cannot just be the same probability each time, but must have the chance to show up as a differnet node, proportional to its probability. It must be SAMPLED.

This needs the participant data by row, and then the model data too. 

There's more! NO need to modify the data in every script. Let's go back and do it in a oner.

```{r}
rm(list=ls())
set.seed(88)
# Get model data
#df <- read.csv('../model_data/modelAndDataUnfitpn.csv') # 288 obs of 21
df <- read.csv('../model_data/fitforplot16mpn.csv') # 288 obs of 28

# Get participant data
load('../Data/Data.Rdata', verbose = T) # This is one big df2, 2580 of 14

datfortest <- df2 %>% 
  arrange(subject_id, trial_id) %>% 
  select(subject_id, trial_id, node3) %>% 
  group_by(subject_id) %>% 
  mutate(row_num = row_number()) 
  

justmp <- df %>% select(trial_id, node3, full)

# 39x9 - just the full model, in wide form
model_predictions_wide <- justmp %>% 
  pivot_wider(
    names_from = node3,
    values_from = full
  )

```

Next section samples a variable as explanation for each participant trial, for that world condition, to match against the participant's answer

```{r}
variable_names <- setdiff(names(model_predictions_wide), "trial_id")

# Sampling function unchanged
sample_variable_name <- function(probabilities, variable_names) {
  sampled_name <- sample(
    x = variable_names,
    size = 1,
    prob = as.numeric(probabilities)
  )
  return(as.character(sampled_name))
}

# Join on all the probabilities for all node values: not needed but good to see what is going on 
joined_df <- datfortest %>%
  left_join(model_predictions_wide, by = "trial_id")

# Prepare a vector to store sampled variable names
sampled_variable <- vector("character", nrow(joined_df))

# Loop over each participant trial 
for (i in seq_len(nrow(joined_df))) {
  # Extract the probabilities for this row (participant)
  probs <- as.numeric(joined_df[i, variable_names])

  # Sample one variable name for this participant, using its probabilities
  sampled_variable[i] <- sample_variable_name(probs, variable_names)
}

# Assign sampled variables as a new column
joined_df$sampled_variable <- sampled_variable

# Select the relevant columns to return
sampled_predictions <- joined_df %>%
  arrange(subject_id, trial_id) %>% 
  group_by(subject_id) %>% 
  mutate(row_num = row_number()) %>%
  ungroup() %>% 
  select(subject_id, trial_id, row_num, node3, sampled_variable)

```


Now merge back in to real participant data. This is for binomial logistic regression so needs certain vars like UNOBSERVED to be 1/0. 

```{r}
modAndDat <- merge(datfortest, sampled_predictions,
                   by = c("subject_id", "trial_id", "row_num", "node3"), all.x = TRUE) %>% 
  select(-row_num)

# Pivot longer - 5160
fortest <- pivot_longer(modAndDat, cols = -c(subject_id, trial_id),
                        names_to = "Respondent",
                                       values_to = "Response")

fortest <- fortest %>% mutate(Observed = factor(!Response%in%c('Au=0','Au=1','Bu=0', 'Bu=1'), levels = c(TRUE, FALSE)))

fortest$subject_id <- as.factor(fortest$subject_id)
fortest$trial_id <- as.factor(fortest$trial_id)
fortest$Respondent <- as.factor(fortest$Respondent)
fortest$Response <- as.factor(fortest$Response)

```

Now do the regression. It shows participants select OBSERVED less often than predicted by the model. This is reported in the section `Unobserved vs observed variables` section.

```{r}
predU <- glmer(Observed ~ Respondent + (1|subject_id) + (1|trial_id), data = fortest, family = binomial(link='logit'))

summary(predU)

coef <- fixef(predU) # -0.181

est <- exp(coef) # 0.834 - exp converts logodds to odds. 
prob <- plogis(coef) #  plogis is exp/(1+exp) and converts logodds to probs

se <- sqrt(diag(vcov(predU))) 

lower_logodds <- coef-(1.96*se)
upper_logodds <- coef+(1.96*se)

lower_or <- exp(lower_logodds) # .744
upper_or <- exp(upper_logodds) # .936
```

That df is a bit smaller than we need for plotting, so make a similar merge of the full df

```{r}
# modAndDat2 <- merge(df2, sampled_predictions, by = c("subject_id", "trial_id", "node3"))
# 
# # Assign variables
# modAndDat <- modAndDat %>% mutate(Observed = factor(!node3%in%c('Au=0','Au=1','Bu=0', 'Bu=1'), levels = c(T,F)))
# 
# # No actually we need it long
# modAndDat2 <- merge(datfortest, sampled_predictions) %>% rename(participants = node3, model = sampled_variable)

# Remove duplicates here too, does it change the answer? Yes, signif goes from *** to **
#modAndDat2 <- modAndDat2[!duplicated(modAndDat2[, c("subject_id", "trial_id", "model")]), ] 


```


TODO: what to do with this from now on. Should we also use it for the Actual/non-Actual analysis? It is more sophisticated.
TO DO: redo the plot for the unobserved section, using this sampled prediction data.
To decide: which is better for plotting: modandDat, or the longer fortest, which is equivalent except it is listed in long form, and has unnecessary col vars removed.

New idea: this can be intermediate script to put it in format for plotting? But it's different when it's by-participant vs aggregate. Maybe need a new plotting script for just by_ppt stuff.

But it's a problem when it doesn't keep all the nice new tags and labels of the bynode, bytrial version of the 288 obs df. Can merge that back in? Still no closer to plotting

```{r}

#df <- df %>% rename(response = node3)

merged <- fortest %>% 
  left_join(df %>% 
              select(trial_id, Response, pgroup, Actual, include, structure, trial_type, trial_structure_type, Variable, SE), 
            by = c("trial_id", "Response"))

```

Think this is now good for plotting?!!

```{r}
write.csv(merged, '../model_data/forplotbyppt.csv')
```